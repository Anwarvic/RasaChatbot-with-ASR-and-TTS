{"version":3,"sources":["node_modules/browser-pack/_prelude.js","index.js","node_modules/base64-js/index.js","node_modules/buffer/index.js","node_modules/ieee754/index.js","src/midi.js","src/midi2wav.js","src/utils/timer.js","src/wav.js"],"names":["f","exports","module","define","amd","g","window","global","self","this","synth","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length","1","WAV","MIDIStream","midiToWav","placeHoldersCount","b64","len","byteLength","toByteArray","j","tmp","placeHolders","arr","Arr","L","revLookup","charCodeAt","tripletToBase64","num","lookup","encodeChunk","uint8","start","end","output","push","join","fromByteArray","extraBytes","parts","len2","Uint8Array","Array","createBuffer","K_MAX_LENGTH","RangeError","buf","__proto__","Buffer","prototype","arg","encodingOrOffset","allocUnsafe","from","value","TypeError","ArrayBuffer","fromArrayBuffer","fromString","fromObject","assertSize","size","alloc","fill","encoding","undefined","checked","string","isEncoding","actual","write","slice","fromArrayLike","array","byteOffset","obj","isBuffer","copy","isArrayBufferView","numberIsNaN","type","isArray","data","toString","SlowBuffer","loweredCase","utf8ToBytes","base64ToBytes","toLowerCase","slowToString","hexSlice","utf8Slice","asciiSlice","latin1Slice","base64Slice","utf16leSlice","swap","b","m","bidirectionalIndexOf","buffer","val","dir","arrayIndexOf","indexOf","lastIndexOf","read","indexSize","readUInt16BE","arrLength","valLength","String","foundIndex","found","hexWrite","offset","Number","remaining","strLen","parsed","parseInt","substr","utf8Write","blitBuffer","asciiWrite","asciiToBytes","latin1Write","base64Write","ucs2Write","utf16leToBytes","base64","Math","min","res","firstByte","codePoint","bytesPerSequence","secondByte","thirdByte","fourthByte","tempCodePoint","decodeCodePointsArray","codePoints","MAX_ARGUMENTS_LENGTH","fromCharCode","apply","ret","out","toHex","bytes","checkOffset","ext","checkInt","max","checkIEEE754","writeFloat","littleEndian","noAssert","ieee754","writeDouble","base64clean","str","trim","replace","INVALID_BASE64_RE","units","Infinity","leadSurrogate","byteArray","c","hi","lo","src","dst","isView","INSPECT_MAX_BYTES","kMaxLength","TYPED_ARRAY_SUPPORT","foo","console","error","Symbol","species","Object","defineProperty","configurable","enumerable","writable","poolSize","allocUnsafeSlow","_isBuffer","compare","x","y","concat","list","pos","swap16","swap32","swap64","arguments","equals","inspect","match","target","thisStart","thisEnd","thisCopy","targetCopy","includes","isFinite","toJSON","_arr","newBuf","subarray","readUIntLE","mul","readUIntBE","readUInt8","readUInt16LE","readUInt32LE","readUInt32BE","readIntLE","pow","readIntBE","readInt8","readInt16LE","readInt16BE","readInt32LE","readInt32BE","readFloatLE","readFloatBE","readDoubleLE","readDoubleBE","writeUIntLE","writeUIntBE","writeUInt8","writeUInt16LE","writeUInt16BE","writeUInt32LE","writeUInt32BE","writeIntLE","limit","sub","writeIntBE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeFloatLE","writeFloatBE","writeDoubleLE","writeDoubleBE","targetStart","set","isLE","mLen","nBytes","eLen","eMax","eBias","nBits","d","NaN","rt","abs","isNaN","floor","log","LN2","_classCallCheck","lastEventTypeByte","readUint8","id","readString","readUint32","event","delta","readVarUint","eventTypeByte","subTypeByte","subType","readUint16","skip","readUint24","hourByte","frameRate","0","2","3","hour","minute","second","frame","subFrame","numerator","denominator","metronome","thirtyseconds","key","scale","param","eventType","channel","noteNumber","velocity","amount","controllerNumber","controllerValue","Timer","args","verbose","midiStream","header","readChunk","SyntaxError","headerStream","trackCount","timeDivision","tracks","progression","events","maxAmplitude","trackChunk","trackStream","track","keep","readEvent","Skip","timer","_event","_i","ticks","addCriticalPoint","_i2","_track","_delta","map","Map","_event2","semitone","_velocity","getTime","has","get","note","pop","time","amplitude","toFixed","sort","maxVelocity","maxVelocityTime","maxChord","maxChordTime","chord","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","iterator","next","done","_event3","err","return","channels","wav","sampleRate","bitsPerSample","writeProgression","duration","ticksPerBeat","criticalPoints","microsecondsPerBeat","criticalPoint","numChannels","bytesPerSample","view","DataView","pointer","ChunkID","ChunkSize","Format","SubChunk1ID","SubChunk1Size","AudioFormat","NumChannels","SampleRate","ByteRate","BlockAlign","BitsPerSample","SubChunk2ID","SubChunk2Size","re","test","_note$match","_note$match2","_slicedToArray","tone","octave","accidental","tones","C","D","E","F","G","A","B","octaves","-1","4","5","6","7","8","9","10","accidentals","bb","","#","##","octaveIndex","toneIndex","charAt","setUint8","getUint8","Blob","typedData","sample","round","k","_ref","_ref$amplitude","blend","reset","frequency","PI","blocksOut","nonZero","fade","stop","blocksIn","skipChannel","sin","notes","amp","off","secs","rest","relativeDuration","_notes$i","seek","writeNote","setString","getString","uint","setUint32","getUint32","setUint16","getUint16","samples"],"mappings":"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","file":"synth.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","'use strict';\r\n\r\nmodule.exports = {\r\n  WAV: require('./src/wav'),\r\n  MIDIStream: require('./src/midi'),\r\n  midiToWav: require('./src/midi2wav')\r\n};\r\n","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction placeHoldersCount (b64) {\n  var len = b64.length\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // the number of equal signs (place holders)\n  // if there are two placeholders, than the two characters before it\n  // represent one byte\n  // if there is only one, then the three characters before it represent 2 bytes\n  // this is just a cheap hack to not do indexOf twice\n  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0\n}\n\nfunction byteLength (b64) {\n  // base64 is 4/3 + up to two characters of the original data\n  return b64.length * 3 / 4 - placeHoldersCount(b64)\n}\n\nfunction toByteArray (b64) {\n  var i, j, l, tmp, placeHolders, arr\n  var len = b64.length\n  placeHolders = placeHoldersCount(b64)\n\n  arr = new Arr(len * 3 / 4 - placeHolders)\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  l = placeHolders > 0 ? len - 4 : len\n\n  var L = 0\n\n  for (i = 0, j = 0; i < l; i += 4, j += 3) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]\n    arr[L++] = (tmp >> 16) & 0xFF\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  if (placeHolders === 2) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[L++] = tmp & 0xFF\n  } else if (placeHolders === 1) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var output = ''\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    output += lookup[tmp >> 2]\n    output += lookup[(tmp << 4) & 0x3F]\n    output += '=='\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])\n    output += lookup[tmp >> 10]\n    output += lookup[(tmp >> 4) & 0x3F]\n    output += lookup[(tmp << 2) & 0x3F]\n    output += '='\n  }\n\n  parts.push(output)\n\n  return parts.join('')\n}\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nvar K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('Invalid typed array length')\n  }\n  // Return an augmented `Uint8Array` instance\n  var buf = new Uint8Array(length)\n  buf.__proto__ = Buffer.prototype\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\n// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\nif (typeof Symbol !== 'undefined' && Symbol.species &&\n    Buffer[Symbol.species] === Buffer) {\n  Object.defineProperty(Buffer, Symbol.species, {\n    value: null,\n    configurable: true,\n    enumerable: false,\n    writable: false\n  })\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (value instanceof ArrayBuffer) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  return fromObject(value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nBuffer.prototype.__proto__ = Uint8Array.prototype\nBuffer.__proto__ = Uint8Array\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  var buf = createBuffer(length)\n\n  var actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  var buf = createBuffer(length)\n  for (var i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  var buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  buf.__proto__ = Buffer.prototype\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    var buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj) {\n    if (isArrayBufferView(obj) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n        return createBuffer(0)\n      }\n      return fromArrayLike(obj)\n    }\n\n    if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n      return fromArrayLike(obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (isArrayBufferView(string) || string instanceof ArrayBuffer) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  newBuf.__proto__ = Buffer.prototype\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : new Buffer(val, encoding)\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// Node 0.10 supports `ArrayBuffer` but lacks `ArrayBuffer.isView`\nfunction isArrayBufferView (obj) {\n  return (typeof ArrayBuffer.isView === 'function') && ArrayBuffer.isView(obj)\n}\n\nfunction numberIsNaN (obj) {\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n","exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","'use strict';\r\n\r\nclass MIDIStream {\r\n  constructor(buffer) {\r\n    this.data = new Uint8Array(buffer);\r\n    this.byteOffset = 0;\r\n    this.lastEventTypeByte = 0x00;\r\n  }\r\n\r\n  readString(byteLength) {\r\n    var byteOffset = this.byteOffset;\r\n\r\n    for (var i = 0, str = ''; i < byteLength; i++) {\r\n      str += String.fromCharCode(this.data[byteOffset + i]);\r\n    }\r\n\r\n    this.byteOffset += byteLength;\r\n\r\n    return str;\r\n  }\r\n\r\n  readUint32() {\r\n    var byteOffset = this.byteOffset;\r\n    var value = (\r\n      (this.data[byteOffset    ] << 24) |\r\n      (this.data[byteOffset + 1] << 16) |\r\n      (this.data[byteOffset + 2] <<  8) |\r\n      (this.data[byteOffset + 3]      )\r\n    );\r\n\r\n    this.byteOffset += 4;\r\n\r\n    return value;\r\n  }\r\n\r\n  readUint24() {\r\n    var byteOffset = this.byteOffset;\r\n    var value = (\r\n      (this.data[byteOffset    ] << 16) |\r\n      (this.data[byteOffset + 1] <<  8) |\r\n      (this.data[byteOffset + 2]      )\r\n    );\r\n\r\n    this.byteOffset += 3;\r\n\r\n    return value;\r\n  }\r\n\r\n  readUint16() {\r\n    var byteOffset = this.byteOffset;\r\n    var value = (\r\n      (this.data[byteOffset    ] << 8) |\r\n      (this.data[byteOffset + 1]     )\r\n    );\r\n\r\n    this.byteOffset += 2;\r\n\r\n    return value;\r\n  }\r\n\r\n  readUint8() {\r\n    var byteOffset = this.byteOffset;\r\n    var value = this.data[byteOffset];\r\n\r\n    this.byteOffset += 1;\r\n\r\n    return value;\r\n  }\r\n\r\n  readInt8() {\r\n    var byteOffset = this.byteOffset;\r\n    var value = this.data[byteOffset];\r\n\r\n    if (value & 0x80 === 0x80) {\r\n      value ^= 0xFFFFFF00;\r\n    }\r\n\r\n    this.byteOffset += 1;\r\n\r\n    return value;\r\n  }\r\n\r\n  readVarUint() {\r\n    var value = 0;\r\n    var uint8;\r\n\r\n    do {\r\n      uint8 = this.readUint8();\r\n      value = (value << 7) + (uint8 & 0x7F);\r\n    } while ((uint8 & 0x80) === 0x80);\r\n\r\n    return value;\r\n  }\r\n\r\n  skip(byteLength) {\r\n    this.byteOffset += byteLength;\r\n  }\r\n\r\n  readChunk() {\r\n    var id = this.readString(4);\r\n    var length = this.readUint32();\r\n    var byteOffset = this.byteOffset;\r\n\r\n    this.byteOffset += length;\r\n\r\n    var data = this.data.slice(byteOffset, this.byteOffset);\r\n\r\n    return {\r\n      id: id,\r\n      length: length,\r\n      data: data.buffer\r\n    };\r\n  }\r\n\r\n  readEvent() {\r\n    var event = {};\r\n\r\n    event.delta = this.readVarUint();\r\n\r\n    var eventTypeByte = this.readUint8();\r\n\r\n    // system event\r\n    if ((eventTypeByte & 0xF0) === 0xF0) {\r\n      switch (eventTypeByte) {\r\n      // meta event\r\n      case 0xFF:\r\n        event.type = 'meta';\r\n\r\n        var subTypeByte = this.readUint8();\r\n        var length = this.readVarUint();\r\n\r\n        switch (subTypeByte) {\r\n        case 0x00:\r\n          event.subType = 'sequenceNumber';\r\n          if (length === 2)\r\n            event.value = this.readUint16();\r\n          else\r\n            this.skip(length);\r\n          break;\r\n        case 0x01:\r\n          event.subType = 'text';\r\n          event.value = this.readString(length);\r\n          break;\r\n        case 0x02:\r\n          event.subType = 'copyrightNotice';\r\n          event.value = this.readString(length);\r\n          break;\r\n        case 0x03:\r\n          event.subType = 'trackName';\r\n          event.value = this.readString(length);\r\n          break;\r\n        case 0x04:\r\n          event.subType = 'instrumentName';\r\n          event.value = this.readString(length);\r\n          break;\r\n        case 0x05:\r\n          event.subType = 'lyrics';\r\n          event.value = this.readString(length);\r\n          break;\r\n        case 0x06:\r\n          event.subType = 'marker';\r\n          event.value = this.readString(length);\r\n          break;\r\n        case 0x07:\r\n          event.subType = 'cuePoint';\r\n          event.value = this.readString(length);\r\n          break;\r\n        case 0x20:\r\n          event.subType = 'midiChannelPrefix';\r\n          if (length === 1)\r\n            event.value = this.readUint8();\r\n          else\r\n            this.skip(length);\r\n          break;\r\n        case 0x2F:\r\n          event.subType = 'endOfTrack';\r\n          if (length > 0)\r\n            this.skip(length);\r\n          break;\r\n        case 0x51:\r\n          event.subType = 'setTempo';\r\n          if (length === 3)\r\n            event.value = this.readUint24();\r\n          else\r\n            this.skip(length)\r\n          break;\r\n        case 0x54:\r\n          event.subType = 'smpteOffset';\r\n          if (length === 5) {\r\n            var hourByte = this.readUint8();\r\n            event.value = {\r\n              frameRate: ({\r\n                0x00: 24,\r\n                0x01: 25,\r\n                0x02: 29.97,\r\n                0x03: 30\r\n              }[hourByte >>> 6]),\r\n              hour: (hourByte & 0x3F),\r\n              minute: this.readUint8(),\r\n              second: this.readUint8(),\r\n              frame: this.readUint8(),\r\n              subFrame: this.readUint8()\r\n            };\r\n          } else {\r\n            this.skip(length);\r\n          }\r\n          break;\r\n        case 0x58:\r\n          event.subType = 'timeSignature';\r\n          if (length === 4) {\r\n            event.value = {\r\n              numerator: this.readUint8(),\r\n              denominator: 1 << this.readUint8(),\r\n              metronome: this.readUint8(),\r\n              thirtyseconds: this.readUint8()\r\n            };\r\n          } else {\r\n            this.skip(length);\r\n          }\r\n          break;\r\n        case 0x59:\r\n          event.subType = 'keySignature';\r\n          if (length === 2) {\r\n            event.value = {\r\n              key: this.readInt8(),\r\n              scale: this.readUint8()\r\n            };\r\n          } else {\r\n            this.skip(length);\r\n          }\r\n          break;\r\n        case 0x7F:\r\n          event.subType = 'sequencerSpecific';\r\n          event.value = this.readString(length);\r\n          break;\r\n        default:\r\n          event.subType = 'unknown';\r\n          event.value = this.readString(length);\r\n        }\r\n        break;\r\n      // sysex event\r\n      case 0xF0:\r\n        event.type = 'sysEx';\r\n\r\n        var length = this.readVarUint();\r\n\r\n        event.value = this.readString(length);\r\n\r\n        break;\r\n      case 0xF7:\r\n        event.type = 'dividedSysEx';\r\n\r\n        var length = this.readVarUint();\r\n\r\n        event.value = this.readString(length);\r\n\r\n        break;\r\n      default:\r\n        event.type = 'unknown';\r\n\r\n        var length = this.readVarUint();\r\n\r\n        event.value = this.readString(length);\r\n      }\r\n    // channel event\r\n    } else {\r\n      var param;\r\n\r\n      // if the high bit is low\r\n      // use running event type mode\r\n      if ((eventTypeByte & 0x80) === 0x00) {\r\n        param = eventTypeByte;\r\n        eventTypeByte = this.lastEventTypeByte;\r\n      } else {\r\n        param = this.readUint8();\r\n        this.lastEventTypeByte = eventTypeByte;\r\n      }\r\n\r\n      var eventType = eventTypeByte >> 4;\r\n\r\n      event.channel = eventTypeByte & 0x0F;\r\n      event.type = 'channel';\r\n\r\n      switch (eventType) {\r\n      case 0x08:\r\n        event.subType = 'noteOff';\r\n\r\n        event.value = {\r\n          noteNumber: param,\r\n          velocity: this.readUint8()\r\n        };\r\n        break;\r\n      case 0x09:\r\n        event.value = {\r\n          noteNumber: param,\r\n          velocity: this.readUint8()\r\n        };\r\n\r\n        // some midi implementations use a noteOn\r\n        // event with 0 velocity to denote noteOff\r\n        if (event.value.velocity === 0) {\r\n          event.subType = 'noteOff';\r\n        } else {\r\n          event.subType = 'noteOn';\r\n        }\r\n        break;\r\n      case 0x0A:\r\n        event.subType = 'noteAftertouch';\r\n\r\n        event.value = {\r\n          noteNumber: param,\r\n          amount: this.readUint8()\r\n        };\r\n        break;\r\n      case 0x0B:\r\n        event.subType = 'controller';\r\n\r\n        event.value = {\r\n          controllerNumber: param,\r\n          controllerValue: this.readUint8()\r\n        };\r\n        break;\r\n      case 0x0C:\r\n        event.subType = 'programChange';\r\n        event.value = param;\r\n        break;\r\n      case 0x0D:\r\n        event.subType = 'channelAftertouch';\r\n        event.value = param;\r\n        break;\r\n      case 0x0E:\r\n        event.subType = 'pitchBend';\r\n        event.value = param + (this.readUint8() << 7);\r\n        break;\r\n      default:\r\n        event.subType = 'unknown';\r\n        event.value = (param << 8) + this.readUint8();\r\n      }\r\n    }\r\n\r\n    return event;\r\n  }\r\n};\r\n\r\nmodule.exports = MIDIStream;\r\n","'use strict';\r\n\r\nconst WAV = require('./wav');\r\nconst MIDIStream = require('./midi');\r\nconst Timer = require('./utils/timer');\r\n\r\nmodule.exports = function midiToWav(buffer, args = {}) {\r\n  if (args.verbose) {\r\n    console.log('parsing MIDI header...');\r\n  }\r\n\r\n  const midiStream = new MIDIStream(buffer);\r\n  const header = midiStream.readChunk();\r\n\r\n  if (header.id !== 'MThd' || header.length !== 6) {\r\n    throw new SyntaxError('malformed header');\r\n  }\r\n\r\n  const headerStream = new MIDIStream(header.data);\r\n  const formatType = headerStream.readUint16();\r\n  const trackCount = headerStream.readUint16();\r\n  const timeDivision = headerStream.readUint16();\r\n  const tracks = [];\r\n  const progression = [];\r\n  const events = [];\r\n  let maxAmplitude;\r\n\r\n  for (let i = 0; i < trackCount; i++) {\r\n    if (args.verbose) {\r\n      console.log(`parsing track ${i + 1}...`);\r\n    }\r\n\r\n    const trackChunk = midiStream.readChunk();\r\n\r\n    if (trackChunk.id !== 'MTrk') {\r\n      continue;\r\n    }\r\n\r\n    const trackStream = new MIDIStream(trackChunk.data);\r\n    const track = [];\r\n    let keep = true;\r\n\r\n    // determine whether applied filter will remove the current track while populating it\r\n    while (keep && trackStream.byteOffset < trackChunk.length) {\r\n      let event = trackStream.readEvent();\r\n      track.push(event);\r\n\r\n      if (typeof event.value === 'string') {\r\n        if (args.verbose) {\r\n          console.log(`{\"${event.subType}\":\"${event.value}\"}`);\r\n        }\r\n\r\n        if (Array.isArray(args.Skip)) {\r\n          for (let t = 0; t < args.Skip.length; t++) {\r\n            if (args.Skip[t][event.subType] === event.value) {\r\n              if (args.verbose) {\r\n                console.log(`skip match found: {\"${event.subType}\":\"${event.value}\"}`);\r\n              }\r\n\r\n              keep = false;\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (typeof args.Skip === 'function') {\r\n      keep = !args.Skip(track);\r\n    }\r\n\r\n    if (keep) {\r\n      tracks.push(track);\r\n    } else if (args.verbose) {\r\n      console.log(`skipping track ${i + 1}...`);\r\n    }\r\n  }\r\n\r\n  if (timeDivision >>> 15 === 0) {\r\n    // use microseconds per beat\r\n    const timer = new Timer(timeDivision);\r\n\r\n    if (args.verbose) {\r\n      console.log('initializing timer...');\r\n    }\r\n\r\n    // set up timer with setTempo events\r\n    for (let i = 0, delta = 0, ticks = 0, event; i < tracks[0].length; i++) {\r\n      event = tracks[0][i];\r\n      delta += event.delta;\r\n      ticks += event.delta;\r\n\r\n      if (event.subType === 'setTempo') {\r\n        timer.addCriticalPoint(delta, event.value);\r\n        delta = 0;\r\n      }\r\n    }\r\n\r\n    // generate note data\r\n    for (let i = 0; i < tracks.length; i++) {\r\n      if (args.verbose) {\r\n        console.log(`generating progression from track ${i + 1}...`);\r\n      }\r\n\r\n      let track = tracks[i];\r\n      let delta = 0;\r\n      let map = new Map();\r\n\r\n      for (let j = 0; j < track.length; j++) {\r\n        let event = track[j];\r\n        delta += event.delta;\r\n\r\n        if (event.type === 'channel') {\r\n          const semitone = event.value.noteNumber;\r\n\r\n          if (event.subType === 'noteOn') {\r\n            let velocity = event.value.velocity;\r\n            let offset = timer.getTime(delta);\r\n\r\n            // use stack for simultaneous identical notes\r\n            if (map.has(semitone)) {\r\n              map.get(semitone).push({offset, velocity});\r\n            } else {\r\n              map.set(semitone, [{offset, velocity}]);\r\n            }\r\n\r\n            // to determine maximum total velocity for normalizing volume\r\n            events.push({velocity, delta, note: true});\r\n          } else if (event.subType === 'noteOff') {\r\n            let note = map.get(semitone).pop();\r\n\r\n            progression.push({\r\n              note: WAV.note(semitone),\r\n              time: timer.getTime(delta) - note.offset,\r\n              amplitude: note.velocity / 128,\r\n              offset: note.offset,\r\n            });\r\n\r\n            // to determine maximum total velocity for normalizing volume\r\n            events.push({velocity: note.velocity, delta, note: false});\r\n          }\r\n        } else if (args.verbose && event.type === 'meta') {\r\n          if (typeof event.value === 'string') {\r\n            console.log(`${timer.getTime(delta).toFixed(2)}s ${event.subType}: ${event.value}`);\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    if (args.verbose) {\r\n      console.log('normalizing volume...');\r\n    }\r\n\r\n    events.sort(function (a, b) {\r\n      return a.delta - b.delta || a.note - b.note;\r\n    });\r\n\r\n    if (args.verbose) {\r\n      console.log('total notes:', progression.length);\r\n      console.log('total time:', timer.getTime(events[events.length - 1].delta), 'seconds');\r\n    }\r\n\r\n    let maxVelocity = 1;\r\n    let maxVelocityTime = 0;\r\n    let velocity = 1;\r\n    let maxChord = 0;\r\n    let maxChordTime = 0;\r\n    let chord = 0;\r\n\r\n    for (const event of events) {\r\n      if (event.note) {\r\n        velocity += event.velocity;\r\n        chord++;\r\n\r\n        if (velocity > maxVelocity) {\r\n          maxVelocity = velocity;\r\n          maxVelocityTime = timer.getTime(event.delta);\r\n        }\r\n\r\n        if (chord > maxChord) {\r\n          maxChord = chord;\r\n          maxChordTime = timer.getTime(event.delta);\r\n        }\r\n      } else {\r\n        velocity -= event.velocity;\r\n        chord--;\r\n      }\r\n    }\r\n\r\n    // scaling factor for amplitude\r\n    maxAmplitude = 128 / maxVelocity;\r\n\r\n    if (args.verbose) {\r\n      console.log('setting volume to', maxAmplitude);\r\n      console.log('  maximum chord of', maxChord, 'at', maxChordTime, 'seconds');\r\n      console.log('  maximum velocity of', maxVelocity - 1, 'at', maxVelocityTime, 'seconds');\r\n    }\r\n  } else {\r\n    // use frames per second\r\n    // not yet implemented\r\n\r\n    console.log('Detected unsupported MIDI timing mode');\r\n\r\n    return null;\r\n\r\n    /*\r\n    let framesPerSecond = (division >>> 8) & 0x7F;\r\n    let ticksPerFrame = division & 0xFF;\r\n\r\n    if (framesPerSecond === 29) {\r\n      framesPerSecond = 29.97;\r\n    }\r\n\r\n    // seconds per tick = 1 / frames per second / ticks per frame\r\n    secsPerTick = 1 / framesPerSecond / ticksPerFrame;\r\n    */\r\n  }\r\n\r\n  // set to mono\r\n  args.channels = 1;\r\n\r\n  if (args.verbose) {\r\n    console.log('generating WAV buffer...');\r\n  }\r\n\r\n  const wav = new WAV(args.channels, args.sampleRate, args.bitsPerSample);\r\n\r\n  wav.writeProgression(progression, maxAmplitude, [0], true, true, args.duration);\r\n\r\n  return wav;\r\n};\r\n","'use strict';\r\n\r\n// utility class to calculate time from delta ticks\r\n// when MIDI file has several `setTempo` events\r\nclass Timer {\r\n  constructor(ticksPerBeat) {\r\n    this.ticksPerBeat = ticksPerBeat;\r\n    this.criticalPoints = [];\r\n  }\r\n\r\n  // delta represents ticks since last time change\r\n  addCriticalPoint(delta, microsecondsPerBeat) {\r\n    this.criticalPoints.push({\r\n      delta,\r\n      microsecondsPerBeat\r\n    });\r\n  }\r\n\r\n  getTime(delta) {\r\n    const microsecondsPerSecond = 1000000;\r\n    let time = 0;\r\n    // midi standard initializes file with this value\r\n    let microsecondsPerBeat = 500000;\r\n\r\n    // iterate through time changes while decrementing delta ticks to 0\r\n    for (let i = 0, criticalPoint; i < this.criticalPoints.length && delta > 0; i++) {\r\n      criticalPoint = this.criticalPoints[i];\r\n\r\n      // incrementally calculate the time passed for each range of timing\r\n      if (delta >= criticalPoint.delta) {\r\n        time += criticalPoint.delta * microsecondsPerBeat / this.ticksPerBeat / microsecondsPerSecond;\r\n        delta -= criticalPoint.delta;\r\n      } else {\r\n        time += delta * microsecondsPerBeat / this.ticksPerBeat / microsecondsPerSecond;\r\n        delta = 0;\r\n      }\r\n\r\n      microsecondsPerBeat = criticalPoint.microsecondsPerBeat;\r\n    }\r\n\r\n    time += delta * microsecondsPerBeat / this.ticksPerBeat / microsecondsPerSecond;\r\n\r\n    return time;\r\n  }\r\n};\r\n\r\nmodule.exports = Timer;\r\n","'use strict';\r\n\r\nclass WAV {\r\n  static semitone(note = 'REST') {\r\n    // matches occurence of A through G\r\n    // followed by positive or negative integer\r\n    // followed by 0 to 2 occurences of flat or sharp\r\n    const re = /^([A-G])(\\-?\\d+)(b{0,2}|#{0,2})$/;\r\n\r\n    // if semitone is unrecognized, assume REST\r\n    if (!re.test(note)) {\r\n      return -Infinity;\r\n    }\r\n\r\n    // parse substrings of note\r\n    const [, tone, octave, accidental] = note.match(re);\r\n\r\n    // semitone indexed relative to A4 == 69 for compatibility with MIDI\r\n    const tones = {C: 0, D: 2, E: 4, F: 5, G: 7, A: 9, B: 11};\r\n    const octaves = {'-1': 0, 0: 1, 1: 2, 2: 3, 3: 4, 4: 5, 5: 6, 6: 7, 7: 8, 8: 9, 9: 10, 10: 11};\r\n    const accidentals = {bb: -2, b: -1, '': 0, '#': 1, '##': 2};\r\n\r\n    // if semitone is unrecognized, assume REST\r\n    if (tones[tone] === undefined || octaves[octave] === undefined || accidentals[accidental] === undefined) {\r\n      return -Infinity;\r\n    }\r\n\r\n    // return calculated index\r\n    return tones[tone] + octaves[octave] * 12 + accidentals[accidental];\r\n  }\r\n\r\n  static note(semitone = -Infinity) {\r\n    const octaves = [-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\r\n    const tones = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];\r\n\r\n    const octaveIndex = Math.floor(semitone / 12);\r\n    const toneIndex = Math.floor(semitone - octaveIndex * 12);\r\n\r\n    const octave = octaves[octaveIndex];\r\n    const tone = tones[toneIndex];\r\n\r\n    // by default assume REST\r\n    if (octave === undefined || tone === undefined) {\r\n      return 'REST';\r\n    }\r\n\r\n    // tone followed by octave followed by accidental\r\n    return tone.charAt(0) + octave.toString() + tone.charAt(1);\r\n  }\r\n\r\n  // converts semitone index to frequency in Hz\r\n  static frequency(semitone = -Infinity) {\r\n    // A4 is 440 Hz, 12 semitones per octave\r\n    return 440 * Math.pow(2, (semitone - 69) / 12);\r\n  }\r\n\r\n  constructor(numChannels = 1, sampleRate = 44100, bitsPerSample = 16, littleEndian = true, data = []) {\r\n    var bytesPerSample = bitsPerSample >>> 3;\r\n    // WAV header is always 44 bytes\r\n    this.header = new ArrayBuffer(44);\r\n    // flexible container for reading / writing raw bytes in header\r\n    this.view = new DataView(this.header);\r\n    // leave sound data as non typed array for more flexibility\r\n    this.data = data;\r\n\r\n    // initialize as non-configurable because it\r\n    // causes script to freeze when using parsed\r\n    // chunk sizes with wrong endianess assumed\r\n    Object.defineProperty(this, 'littleEndian', {\r\n      configurable: false,\r\n      enumerable: true,\r\n      value: littleEndian,\r\n      writable: false\r\n    });\r\n\r\n    // initial write index in data array\r\n    this.pointer = 0;\r\n\r\n    // WAV header properties\r\n    this.ChunkID = littleEndian ? 'RIFF' : 'RIFX';\r\n    this.ChunkSize = this.header.byteLength - 8;\r\n    this.Format = 'WAVE';\r\n    this.SubChunk1ID = 'fmt ';\r\n    this.SubChunk1Size = 16;\r\n    this.AudioFormat = 1;\r\n    this.NumChannels = numChannels;\r\n    this.SampleRate = sampleRate;\r\n    this.ByteRate = numChannels * sampleRate * bytesPerSample;\r\n    this.BlockAlign = numChannels * bytesPerSample;\r\n    this.BitsPerSample = bitsPerSample;\r\n    this.SubChunk2ID = 'data';\r\n    this.SubChunk2Size = data.length * bytesPerSample;\r\n  }\r\n\r\n  // internal setter for writing strings as raw bytes to header\r\n  setString(str, byteLength = str.length, byteOffset = 0) {\r\n    for (var i = 0; i < byteLength; i++) {\r\n      this.view.setUint8(byteOffset + i, str.charCodeAt(i));\r\n    }\r\n  }\r\n\r\n  // internal getter for reading raw bytes as strings from header\r\n  getString(byteLength, byteOffset = 0) {\r\n    for (var i = 0, str = ''; i < byteLength; i++) {\r\n      str += String.fromCharCode(this.view.getUint8(byteOffset + i));\r\n    }\r\n\r\n    return str;\r\n  }\r\n\r\n  // header property mutators\r\n\r\n  // 4 bytes at offset of 0 bytes\r\n  set ChunkID(str) {\r\n    this.setString(str, 4, 0);\r\n  }\r\n\r\n  get ChunkID() {\r\n    return this.getString(4, 0);\r\n  }\r\n\r\n  // 4 bytes at offset of 4 bytes\r\n  set ChunkSize(uint) {\r\n    this.view.setUint32(4, uint, this.littleEndian);\r\n  }\r\n\r\n  get ChunkSize() {\r\n    return this.view.getUint32(4, this.littleEndian);\r\n  }\r\n\r\n  // 4 bytes at offset of 8 bytes\r\n  set Format(str) {\r\n    this.setString(str, 4, 8);\r\n  }\r\n\r\n  get Format() {\r\n    return this.getString(4, 8);\r\n  }\r\n\r\n  // 4 bytes at offset of 12 bytes\r\n  set SubChunk1ID(str) {\r\n    this.setString(str, 4, 12);\r\n  }\r\n\r\n  get SubChunk1ID() {\r\n    return this.getString(4, 12);\r\n  }\r\n\r\n  // 4 bytes at offset of 16 bytes\r\n  set SubChunk1Size(uint) {\r\n    this.view.setUint32(16, uint, this.littleEndian);\r\n  }\r\n\r\n  get SubChunk1Size() {\r\n    return this.view.getUint32(16, this.littleEndian);\r\n  }\r\n\r\n  // 2 bytes at offset of 20 bytes\r\n  set AudioFormat(uint) {\r\n    this.view.setUint16(20, uint, this.littleEndian);\r\n  }\r\n\r\n  get AudioFormat() {\r\n    return this.view.getUint16(20, this.littleEndian);\r\n  }\r\n\r\n  // 2 bytes at offset of 22 bytes\r\n  set NumChannels(uint) {\r\n    this.view.setUint16(22, uint, this.littleEndian);\r\n  }\r\n\r\n  get NumChannels() {\r\n    return this.view.getUint16(22, this.littleEndian);\r\n  }\r\n\r\n  // 4 bytes at offset of 24 bytes\r\n  set SampleRate(uint) {\r\n    this.view.setUint32(24, uint, this.littleEndian);\r\n  }\r\n\r\n  get SampleRate() {\r\n    return this.view.getUint32(24, this.littleEndian);\r\n  }\r\n\r\n  // 4 bytes at offset of 28 bytes\r\n  set ByteRate(uint) {\r\n    this.view.setUint32(28, uint, this.littleEndian);\r\n  }\r\n\r\n  get ByteRate() {\r\n    return this.view.getUint32(28, this.littleEndian);\r\n  }\r\n\r\n  // 2 bytes at offset of 32 bytes\r\n  set BlockAlign(uint) {\r\n    this.view.setUint16(32, uint, this.littleEndian);\r\n  }\r\n\r\n  get BlockAlign() {\r\n    return this.view.getUint16(32, this.littleEndian);\r\n  }\r\n\r\n  // 2 bytes at offset of 34 bytes\r\n  set BitsPerSample(uint) {\r\n    this.view.setUint16(34, uint, this.littleEndian);\r\n  }\r\n\r\n  get BitsPerSample() {\r\n    return this.view.getUint16(34, this.littleEndian);\r\n  }\r\n\r\n  // 4 bytes at offset of 36 bytes\r\n  set SubChunk2ID(str) {\r\n    this.setString(str, 4, 36);\r\n  }\r\n\r\n  get SubChunk2ID() {\r\n    return this.getString(4, 36);\r\n  }\r\n\r\n  // 4 bytes at offset of 40 bytes\r\n  set SubChunk2Size(uint) {\r\n    this.view.setUint32(40, uint, this.littleEndian);\r\n  }\r\n\r\n  get SubChunk2Size() {\r\n    return this.view.getUint32(40, this.littleEndian);\r\n  }\r\n\r\n  // internal getter for sound data as\r\n  // typed array based on header properties\r\n  get typedData() {\r\n    var bytesPerSample = this.BitsPerSample >>> 3;\r\n    var data = this.data;\r\n    var size = this.SubChunk2Size;\r\n    var samples = size / bytesPerSample;\r\n    var buffer = new ArrayBuffer(size);\r\n    var uint8 = new Uint8Array(buffer);\r\n\r\n    // convert signed normalized sound data to typed integer data\r\n    // i.e. [-1, 1] -> [INT_MIN, INT_MAX]\r\n    var amplitude = Math.pow(2, (bytesPerSample << 3) - 1) - 1;\r\n    var i, d;\r\n\r\n    switch (bytesPerSample) {\r\n    case 1:\r\n      // endianess not relevant for 8-bit encoding\r\n      for (i = 0; i < samples; i++) {\r\n        // convert by adding 0x80 instead of 0x100\r\n        // WAV uses unsigned data for 8-bit encoding\r\n\r\n        // [INT8_MIN, INT8_MAX] -> [0, UINT8_MAX]\r\n        uint8[i] = (data[i] * amplitude + 0x80) & 0xFF;\r\n      }\r\n      break;\r\n    case 2:\r\n      // LSB first\r\n      if (this.littleEndian) {\r\n        for (i = 0; i < samples; i++) {\r\n          // [INT16_MIN, INT16_MAX] -> [0, UINT16_MAX]\r\n          d = (data[i] * amplitude + 0x10000) & 0xFFFF;\r\n\r\n          // unwrap inner loop\r\n          uint8[i * 2    ] = (d      ) & 0xFF;\r\n          uint8[i * 2 + 1] = (d >>> 8);\r\n        }\r\n      // MSB first\r\n      } else {\r\n        for (i = 0; i < samples; i++) {\r\n          // [INT16_MIN, INT16_MAX] -> [0, UINT16_MAX]\r\n          d = (data[i] * amplitude + 0x10000) & 0xFFFF;\r\n\r\n          // unwrap inner loop\r\n          uint8[i * 2    ] = (d >>> 8);\r\n          uint8[i * 2 + 1] = (d      ) & 0xFF;\r\n        }\r\n      }\r\n      break;\r\n    case 3:\r\n      // LSB first\r\n      if (this.littleEndian) {\r\n        for (i = 0; i < samples; i++) {\r\n          // [INT24_MIN, INT24_MAX] -> [0, UINT24_MAX]\r\n          d = (data[i] * amplitude + 0x1000000) & 0xFFFFFF;\r\n\r\n          // unwrap inner loop\r\n          uint8[i * 3    ] = (d       ) & 0xFF;\r\n          uint8[i * 3 + 1] = (d >>>  8) & 0xFF;\r\n          uint8[i * 3 + 2] = (d >>> 16);\r\n        }\r\n      // MSB first\r\n      } else {\r\n        for (i = 0; i < samples; i++) {\r\n          // [INT24_MIN, INT24_MAX] -> [0, UINT24_MAX]\r\n          d = (data[i] * amplitude + 0x1000000) & 0xFFFFFF;\r\n\r\n          // unwrap inner loop\r\n          uint8[i * 3    ] = (d >>> 16);\r\n          uint8[i * 3 + 1] = (d >>>  8) & 0xFF;\r\n          uint8[i * 3 + 2] = (d       ) & 0xFF;\r\n        }\r\n      }\r\n    case 4:\r\n      // LSB first\r\n      if (this.littleEndian) {\r\n        for (i = 0; i < samples; i++) {\r\n          // [INT32_MIN, INT32_MAX] -> [0, UINT32_MAX]\r\n          d = (data[i] * amplitude + 0x100000000) & 0xFFFFFFFF;\r\n\r\n          // unwrap inner loop\r\n          uint8[i * 4    ] = (d       ) & 0xFF;\r\n          uint8[i * 4 + 1] = (d >>>  8) & 0xFF;\r\n          uint8[i * 4 + 2] = (d >>> 16) & 0xFF;\r\n          uint8[i * 4 + 3] = (d >>> 24);\r\n        }\r\n      // MSB first\r\n      } else {\r\n        for (i = 0; i < samples; i++) {\r\n          // [INT32_MIN, INT32_MAX] -> [0, UINT32_MAX]\r\n          d = (data[i] * amplitude + 0x100000000) & 0xFFFFFFFF;\r\n\r\n          // unwrap inner loop\r\n          uint8[i * 4    ] = (d >>> 24);\r\n          uint8[i * 4 + 1] = (d >>> 16) & 0xFF;\r\n          uint8[i * 4 + 2] = (d >>>  8) & 0xFF;\r\n          uint8[i * 4 + 3] = (d       ) & 0xFF;\r\n        }\r\n      }\r\n    }\r\n\r\n    return buffer;\r\n  }\r\n\r\n  // binary container outputs\r\n\r\n  // browser-specific\r\n  // generates blob from concatenated typed arrays\r\n  toBlob() {\r\n    return new Blob([this.header, this.typedData], {type: 'audio/wav'});\r\n  }\r\n\r\n  // Node.js-specific\r\n  // generates buffer from concatenated typed arrays\r\n  toBuffer() {\r\n    return Buffer.concat([Buffer.from(this.header), Buffer.from(this.typedData)]);\r\n  }\r\n\r\n  // pointer mutators\r\n\r\n  // gets time (in seconds) of pointer\r\n  tell() {\r\n    return this.pointer / this.NumChannels / this.SampleRate;\r\n  }\r\n\r\n  // sets time (in seconds) of pointer\r\n  // zero-fills by default\r\n  seek(time, fill = true) {\r\n    var data   = this.data;\r\n    var sample = Math.round(this.SampleRate * time);\r\n\r\n    this.pointer = this.NumChannels * sample;\r\n\r\n    if (fill) {\r\n      // zero-fill seek\r\n      while (data.length < this.pointer) {\r\n        data[data.length] = 0;\r\n      }\r\n    } else {\r\n      this.pointer = data.length;\r\n    }\r\n  }\r\n\r\n  // sound data mutators\r\n\r\n  // writes the specified note to the sound data\r\n  // for amount of time in seconds\r\n  // at given normalized amplitude\r\n  // to channels listed (or all by default)\r\n  // adds to existing data by default\r\n  // and does not reset write index after operation by default\r\n  writeNote({note, time, amplitude = 1}, channels = [], blend = true, reset = false) {\r\n    // creating local references to properties\r\n    var data = this.data;\r\n    var numChannels = this.NumChannels;\r\n    var sampleRate = this.SampleRate;\r\n\r\n    // to prevent sound artifacts\r\n    const fadeSeconds = 0.001;\r\n\r\n    // calculating properties of given note\r\n    var semitone = WAV.semitone(note);\r\n    var frequency = WAV.frequency(semitone) * Math.PI * 2 / sampleRate;\r\n    var period = Math.PI * 2 / frequency;\r\n\r\n    // amount of blocks to be written\r\n    var blocksOut = Math.round(sampleRate * time);\r\n    // reduces sound artifacts by fading at last fadeSeconds\r\n    var nonZero = blocksOut - sampleRate * fadeSeconds;\r\n    // fade interval in samples\r\n    var fade = blocksOut - nonZero + 1;\r\n\r\n    // index of start and stop samples\r\n    var start = this.pointer;\r\n    var stop = data.length;\r\n\r\n    // determines amount of blocks to be updated\r\n    var blocksIn = Math.min(Math.floor((stop - start) / numChannels), blocksOut);\r\n\r\n    // i = index of each sample block\r\n    // j = index of each channel in a block\r\n    // k = cached index of data\r\n    // d = sample data value\r\n    var i, j, k, d;\r\n\r\n    // by default write to all channels\r\n    if (channels.length === 0) {\r\n      // don't overwrite passed array\r\n      channels = [];\r\n\r\n      for (i = 0; i < numChannels; i++) {\r\n        channels[i] = i;\r\n      }\r\n    }\r\n\r\n    // inline .indexOf() function calls into array references\r\n    var skipChannel = [];\r\n\r\n    for (i = 0; i < numChannels; i++) {\r\n      skipChannel[i] = (channels.indexOf(i) === -1);\r\n    }\r\n\r\n    // update existing data\r\n    for (i = 0; i < blocksIn; i++) {\r\n      // iterate through specified channels\r\n      for (j = 0; j < channels.length; j++) {\r\n        k = start + i * numChannels + channels[j];\r\n        d = 0;\r\n\r\n        if (frequency > 0) {\r\n          d = amplitude * Math.sin(frequency * i) * ((i < fade) ? i : (i > nonZero) ? blocksOut - i + 1 : fade) / fade;\r\n        }\r\n\r\n        data[k] = d + (blend ? data[k] : 0);\r\n      }\r\n    }\r\n\r\n    // append data\r\n    for (i = blocksIn; i < blocksOut; i++) {\r\n      k = start + i * numChannels;\r\n\r\n      // iterate through all channels\r\n      for (j = 0; j < numChannels; j++) {\r\n        d = 0;\r\n\r\n        // only write non-zero data to specified channels\r\n        if (frequency > 0 || !skipChannel[j]) {\r\n          d = amplitude * Math.sin(frequency * i) * ((i < fade) ? i : (i > nonZero) ? blocksOut - i + 1 : fade) / fade;\r\n        }\r\n\r\n        data[k + j] = d;\r\n      }\r\n    }\r\n\r\n    // update header properties\r\n    var end = Math.max(start + blocksOut * numChannels, stop) * this.BitsPerSample >>> 3;\r\n\r\n    this.ChunkSize = end + this.header.byteLength - 8;\r\n    this.SubChunk2Size = end;\r\n\r\n    if (!reset) {\r\n      // move write index to end of written data\r\n      this.pointer = start + blocksOut * numChannels;\r\n    }\r\n  }\r\n\r\n  // adds specified notes in series\r\n  // (or asynchronously if offset property is specified in a note)\r\n  // each playing for time * relativeDuration seconds\r\n  // followed by a time * (1 - relativeDuration) second rest\r\n  writeProgression(notes, amplitude = 1, channels = [], blend = true, reset = false, relativeDuration = 1) {\r\n    var start = this.pointer;\r\n\r\n    for (var i = 0, note, time, amp, off, secs, rest; i < notes.length; i++) {\r\n      ({note, time, amplitude: amp, offset: off} = notes[i]);\r\n\r\n      // for asynchronous progression\r\n      if (off !== undefined) {\r\n        this.seek(off);\r\n      }\r\n\r\n      if (relativeDuration === 1 || note === 'REST') {\r\n        this.writeNote({note, time, amplitude: amp === undefined ? amplitude : amp * amplitude}, channels, blend, false);\r\n      } else {\r\n        secs = time * relativeDuration;\r\n        rest = time - secs;\r\n\r\n        this.writeNote({note: note, time: secs, amplitude: amp === undefined ? amplitude : amp * amplitude}, channels, blend, false);\r\n        this.writeNote({note: 'REST', time: rest}, channels, blend, false);\r\n      }\r\n    }\r\n\r\n    if (reset) {\r\n      this.pointer = start;\r\n    }\r\n  }\r\n};\r\n\r\nmodule.exports = WAV;\r\n"]}